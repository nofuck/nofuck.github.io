<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nofuck.github.io</id>
    <title>nofuck</title>
    <updated>2020-02-22T04:58:34.497Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nofuck.github.io"/>
    <link rel="self" href="https://nofuck.github.io/atom.xml"/>
    <subtitle>只有颓废是不需要努力得来的</subtitle>
    <logo>https://nofuck.github.io/images/avatar.png</logo>
    <icon>https://nofuck.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, nofuck</rights>
    <entry>
        <title type="html"><![CDATA[cf613 E Delete a Segment]]></title>
        <id>https://nofuck.github.io/post/cf613-e-delete-a-segment/</id>
        <link href="https://nofuck.github.io/post/cf613-e-delete-a-segment/">
        </link>
        <updated>2020-02-20T13:29:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题意">题意</h1>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n&lt;=1e5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>个区间，要求删掉一个区间，使剩下的区间不覆盖的个数。</p>
<h1 id="思路">思路</h1>
<h2 id="2中做法">2中做法</h2>
<h4 id="线段树">线段树</h4>
<p>首先给出的区间是乱序的，对其排个序，然后我们可以一次枚举删掉这个区间，然后求剩下的区间所剩的个数。可以用线段树来进行更新查询，可以类似求区间连续01个数那种方式，但我们由于这里是区间，所以把点化为区间，把区间扩大2倍<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo>∗</mo><mi>l</mi><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[2*l,2*r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，然后多加入这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo>∗</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2*l+1,2*r+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>来进行离散化，最后就是区间线段树的操作，只不过pushup的时候我们有细节，如果这个区间全部被覆盖，那么就不用从下面得到答案，直接更新为1就ok了</p>
<h4 id="code">code</h4>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 4e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int a[man*2];

struct node{
    int cnt;
    bool lc,rc;//这段区间的左右区间是否被覆盖
    node(){
        cnt = 0;
        lc = rc = 0;
    }
}tr[man*30];
int flag[man*30];

void build(int l,int r,int rt){
    flag[rt] = 0;
    tr[rt].cnt = 0;
    tr[rt].lc = tr[rt].rc = 0;
    if(l==r){
        //把叶子的下面给清掉
        tr[rt&lt;&lt;1].cnt = tr[rt&lt;&lt;1|1].cnt = 0;
        tr[rt&lt;&lt;1].lc = tr[rt&lt;&lt;1].rc = 0;
        tr[rt&lt;&lt;1|1].lc = tr[rt&lt;&lt;1|1].rc = 0;
        return;
    }
    int m = l + r &gt;&gt; 1;
    build(l,m,rt&lt;&lt;1);
    build(m+1,r,rt&lt;&lt;1|1);
}

void pushup(int rt){
    if(flag[rt]){//如果这整个区间都覆盖，则就为1了，
        tr[rt].cnt = 1;
        tr[rt].lc = tr[rt].rc = 1;
    }else{
        tr[rt].cnt = tr[rt&lt;&lt;1].cnt  + tr[rt&lt;&lt;1|1].cnt;
        if(tr[rt&lt;&lt;1].rc&amp;&amp;tr[rt&lt;&lt;1|1].lc)tr[rt].cnt--;
        tr[rt].lc = tr[rt&lt;&lt;1].lc;
        tr[rt].rc = tr[rt&lt;&lt;1|1].rc;
    }
}

void update(int l,int r,int L,int R,int rt,int v){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        flag[rt]+= v;//打标机并更新。
        pushup(rt);
        return;
    }
    int m = l + r &gt;&gt;1;  
    if(L&lt;=m)update(l,m,L,R,rt&lt;&lt;1,v);
    if(R&gt;m)update(m+1,r,L,R,rt&lt;&lt;1|1,v);
    pushup(rt);
}

pair&lt;int,int&gt;b[man];
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            int l,r;
            cin &gt;&gt; l &gt;&gt; r;
            l = l*2;r = 2*r;
            b[i].first = l;
            b[i].second = r;
            a[cnt++] = l;
            a[cnt++] = l+1;
            a[cnt++] = r;
            a[cnt++] = r+1;
        }
        sort(a,a+cnt);
        cnt = unique(a,a+cnt) - a;
        build(1,cnt,1);
        int ans = -1;
        for(int i = 1;i &lt;= n;i++){
            int l = lower_bound(a,a+cnt,b[i].first) - a + 1;
            int r = lower_bound(a,a+cnt,b[i].second) - a + 1;
            update(1,cnt,l,r,1,1);
        }
        for(int i = 1;i &lt;= n;i++){
            int l = lower_bound(a,a+cnt,b[i].first) - a + 1;
            int r = lower_bound(a,a+cnt,b[i].second) - a + 1;
            update(1,cnt,l,r,1,-1);
            ans = max(ans,tr[1].cnt);
            update(1,cnt,l,r,1,1);
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }   
    return 0;
}
</code></pre>
<h3 id="单调栈">单调栈</h3>
<p>首先考虑我们删掉中间的一个 线段，左边的个数我们可以通过前缀num得到，num[i]就是前i个区间有多少个不相邻的区间，然后可以用max_r来得到,如果当前的L大于max_r[i-1]，那么num就会增加一个，依次累加就ok，那么右边的区间又如何得到，因为我们的l从后往前，依次递减，然后我们只需要最小的L，与最小的L的区间相互重叠的区间我们是用不到的，因为可以看成一个区间，所以只有这个最小的L有用，然后右边的一部分我们可以用单调栈维护L（后往前）。<br>
整个过程就是从后往前得到答案，然后维护单调栈里的元素，每次的答案就是num[i-1] + cnt<br>
cnt就是单调栈里大于max_r[i-1]的个数，可以二分得到</p>
<h4 id="code-2">code</h4>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
pair&lt;int,int&gt;sp[man];
int num[man],sta[man],max_r[man];
int top;

int bin(int x){
    int l = 1,r = top;
    int ans = 0;
    while(l&lt;=r){
        int mid = l + r &gt;&gt; 1;
        if(sta[mid]&gt;=x){
            l = mid + 1;
            ans = mid;
        }else r = mid - 1;
    }
    if(sta[ans]==x)ans--;
    return ans;
}


int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        max_r[0] = -INT_MAX;
        num[0] = 0;top= 0;
        for(int i = 1;i &lt;= n;++i){
            scanf(&quot;%d%d&quot;,&amp;sp[i].first,&amp;sp[i].second);
        }
        sort(sp+1,sp+1+n);
        for(int i = 1;i &lt;= n;++i){
            max_r[i] = max(sp[i].second,max_r[i-1]);
            if(sp[i].first&gt;max_r[i-1])num[i] = 1;
            num[i] += num[i-1];
        }
        int ans = 0;
        for(int i = n;i &gt;= 1;i--){
            ans = max(ans,num[i-1]+bin(max_r[i-1]));
            while(top&amp;&amp;sp[i].second&gt;=sta[top])top--;
            sta[++top] = sp[i].first;
            num[i] = 0;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019icpc上海区域赛B,K,D,E,F,H]]></title>
        <id>https://nofuck.github.io/post/2019icpc-shang-hai-qu-yu-sai-bkdefh/</id>
        <link href="https://nofuck.github.io/post/2019icpc-shang-hai-qu-yu-sai-bkdefh/">
        </link>
        <updated>2020-02-20T13:26:21.000Z</updated>
        <content type="html"><![CDATA[<p>😊😊</p>
<h1 id="bprefix-code"><a href="https://ac.nowcoder.com/acm/contest/4370/B">B	Prefix Code</a></h1>
<p>题意：给出n个数字(有前缀0)，长度均小于10，问是否有一个数是其他数的前缀？<br>
思路：字典树查找即可，vis表示走过的路径和ed标记结尾，在insert就可判断。</p>
<h3 id="code">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e4+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

int tr[man*15][10];
int cnt = 0;
int vis[man*15];
bool ed[man*15];
bool ans;
void insert(const char *s){
    int p = 0;
    for(int i = 0;s[i];i++){
        int tp = s[i] - '0';
        if(!tr[p][tp])tr[p][tp] = ++cnt;
        p = tr[p][tp];
        if(ed[p])ans = 1;//这个数包含其它前缀
        vis[p]++;
    }
    if(vis[p]&gt;1)ans = 1;//这个数为其它数的前缀
    ed[p] = 1;
}

void init(){
    for(int i = 0;i &lt;= cnt;i++){
        memset(tr[i],0,sizeof(tr[i]));
        vis[i] = 0;
        ed[i] = 0;
    }
    cnt = 0;
    ans = 0;
}

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt;t;
    int T = 1;
    while(t--){
        int n;
        init();
        cin &gt;&gt; n;
        char str[15];
        while(n--){
            cin &gt;&gt; str;
            insert(str);
        }
        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; T++ &lt;&lt;&quot;:&quot;;
        if(ans)cout &lt;&lt; &quot; No\n&quot;;
        else cout &lt;&lt; &quot; Yes\n&quot;;  
    }   
    return 0;
}
</code></pre>
<h1 id="kcolor-graph"><a href="https://ac.nowcoder.com/acm/contest/4370/K">K	Color Graph</a></h1>
<p>题意：给定一个简单图，点个数&lt;=16，对一些边涂色，使得该图中涂过色没有奇数的环，问涂色的边数最大为多少。<br>
思路：<strong>如果一个图中不存在奇数环,那么这个图一定是二分图(首先如果没有环(树)，那么一定是二分图，如果有偶数环，那么从左边的点出去到右边肯定是奇数次，如果要回到左边肯定得是偶数，所以粗略可得。)<a href="https://www.cnblogs.com/ninedream/p/11203942.html">证明</a></strong>，然后点数很小，所以二进制枚举二分图左边的点数，取个最大值。</p>
<h3 id="code-2">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e4+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

vector&lt;pair&lt;int,int&gt; &gt;sp;
bool vis[20];

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    IOS;
    int t;
    cin &gt;&gt;t;
    int T = 1;
    while(t--){
        int n,m;
        cin &gt;&gt; n &gt;&gt; m;
        sp.clear();
        memset(vis,0,sizeof(vis));
        for(int i = 1;i &lt;= m;++i){
            int u,v;
            cin &gt;&gt; u &gt;&gt; v;
            sp.push_back(make_pair(u,v));
        }
        int ans = 0;
        for(int i = 0;i &lt; (1&lt;&lt;n);++i){
            int tp = i;
            for(int j = 1;j &lt;= n;j++){
                if(tp&gt;&gt;(j-1)&amp;1)vis[j] = 1;
                else vis[j] = 0;
            }
            int res = 0;
            for(int j = 0;j &lt; sp.size();++j){
                if(vis[sp[j].first]!=vis[sp[j].second])res++;
            }
            ans = max(ans,res);
        }
        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; T++ &lt;&lt;&quot;: &quot;;
        cout &lt;&lt; ans &lt;&lt; endl;
    }   
    return 0;
}
</code></pre>
<h1 id="htree-partition"><a href="https://ac.nowcoder.com/acm/contest/4370/H">H	Tree Partition</a></h1>
<p>题意：一颗(n&lt;=1e5)的树，要求把其分为(k&lt;=n)个子树，要求每个子树的最大值最小。<br>
思路：首先二分最大值mid，然后在对于这个最大值check，让每颗树都尽量的大(&lt;=x)，以致于我们砍的次数少，如果砍的次数多了，那么说明这个max小了，反之则大了。</p>
<h3 id="code-3">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
vector&lt;int&gt;sp[man];
int tp[man];
ll va[man];
const ll inf = 1e18;
ll mid;
int kk;

struct node{
    int u;
    node(int u = 0):u(u){}
    bool operator &lt; (const node &amp;t)const{
        return va[u] &lt; va[t.u];
    }
};


ll dfs(int u,int f){
    priority_queue&lt;node&gt;q;
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==f)continue;
        va[u] += dfs(v,u);
        q.push(node(v));
    }
    while(va[u]&gt;mid&amp;&amp;!q.empty()){
        va[u] -= va[q.top().u];
        q.pop();
        kk++;
    }
    while(!q.empty())q.pop();
    return va[u];
}

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    int T = 0;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        int k,n;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        //while(!q.empty())q.pop();
        for(int i = 1;i &lt;= n;i++)sp[i].clear();
        for(int i = 1;i &lt; n;i++){
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            sp[u].push_back(v);
            sp[v].push_back(u);
        }
        ll l = 0,r = inf;
        for(int i = 1;i &lt;= n;i++)scanf(&quot;%d&quot;,&amp;tp[i]),l = max(l,1ll*tp[i]);
        ll ans = 0;
        while(l&lt;=r){
            mid = l + r &gt;&gt; 1;
            for(int i = 1;i &lt;= n;i++)va[i] = tp[i];
            kk = 0;
            dfs(1,0);
            if(kk+1&lt;=k)r = mid - 1,ans = mid;
            else l = mid + 1; 
        }
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h1 id="dspanning-tree-removal"><a href="https://ac.nowcoder.com/acm/contest/4370/D">D	Spanning Tree Removal</a></h1>
<p>题意：给定一个n的完全图，每次操作是从图中移除一棵生成树的所有边，问最多能进行多少次这样的操作？输出操作次数和每次移除的生成树的边。<br>
思路：边n*(n-1)/2,每颗生成树为n-1条边，所以猜测n/2条边，构造方法的话也比较巧;<br>
所有点顺时针编号(0~n-1)<br>
以x为起点，连接的点y为顺时针+1<br>
从y找下一个点，连接的点z为逆时针-2<br>
然后形成一个z字。</p>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

int main() {
    #ifndef ONLINE_JUDGE
        freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt; t;
    int T = 0;
    while(t--){
        int n;cin &gt;&gt; n;
        printf(&quot;Case #%d: %d\n&quot;,++T,n/2);
        for(int i = 1;i &lt;= n/2;i++){
            int f = 1;
            int u = i - 1;
            for(int j = 1;j &lt; n;j++){
                int v = (u + j*f + n)%n;
                printf(&quot;%d %d\n&quot;,u+1,v+1);
                f *= -1;
                u = v;
            }
        }
    }
    return 0;
}
</code></pre>
<h1 id="ecave-escape"><a href="https://ac.nowcoder.com/acm/contest/4370/E">E	Cave Escape</a></h1>
<p>题意：给定一个n∗m的格子矩阵，其中有一个格子是起点，一个格子是终点。从起点开始移动，每次能移动到有相邻边的格子中，每个格子都有一个权值v,若从点a移动到点b，且b点未被访问过，则可以获得Va∗Vb的收益，若移动到终点，可以选择先不出去，继续在图上乱走，问如何可以使得走出终点后获得得收益最大？(只需要输出最大收益即可)<br>
思路：不管起点在哪里，因为权值都为正数，我们要让收益最大，肯定尽量每个点都访问一遍，然后才是最大的值，所以我们可以直接建图，然后跑一遍生成树(最大),因为要让每个点访问一次。<br>
正解的话存图是把权值作为索引，然后从大到小一次枚举；<br>
一般的做法可以卡过去。</p>
<h3 id="code正解805ms">code(正解805ms)</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e3+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int x[man*man],fa[man*man],va[man][man];
int sz[man*man];
vector&lt;pair&lt;int,int&gt; &gt;A[10010];
int find(int x){
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}
/*
int find(int x){
    int p = x;
    while(p!=fa[p])p = fa[p];
    while(x!=p){
        int tp = fa[x];
        fa[x] = p;
        x = tp;
    }
    return p;
}*/
 
bool _union(int u,int v){
   // cout &lt;&lt; u &lt;&lt; &quot; 1\&quot; &quot; &lt;&lt; v &lt;&lt;endl;
    u = find(u);
    v = find(v);
  //  cout &lt;&lt; u &lt;&lt; &quot; 2\&quot; &quot; &lt;&lt; v &lt;&lt; endl;
    if(u==v)return true;
    if(sz[u]&gt;sz[v]){
        sz[u] += sz[v];
        fa[v] = u;
    }else fa[u] = v,sz[v] += sz[u];
    return false;
}
 
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int T = 0;
    while(t--){
        int n,m,s,a,b,c,p;
        for(int i = 0;i &lt;= 10000;i++)A[i].clear();
        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;s,&amp;s,&amp;s);
        scanf(&quot;%d%d%d%d%d%d&quot;,x+1,x+2,&amp;a,&amp;b,&amp;c,&amp;p);
        fa[1] = 1;
        fa[2] = 2;
        for(int i = 3;i &lt;= n*m;i++){
            fa[i] = i;
            sz[i] = 1;
            x[i] = (a*x[i-1] + b*x[i-2] + c)%p;
        }
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            for(int j = 1;j &lt;= m;j++){
                va[i][j] = x[(i-1)*m + j];
                if(!va[i][j])continue;
                if(i&gt;1&amp;&amp;va[i-1][j])A[va[i][j]*va[i-1][j]].push_back(make_pair((i-1)*m + j,(i-2)*m + j));
                if(j&gt;1&amp;&amp;va[i][j-1])A[va[i][j]*va[i][j-1]].push_back(make_pair((i-1)*m + j,(i-1)*m + j - 1));
            }
        }
        ll ans = 0;
        int res = 0;
        for(int j = 10000;j &gt;= 0;j--){
            for(int i = 0;i &lt; A[j].size();i++){
                int u = A[j][i].first;
                int v = A[j][i].second;
                //cout &lt;&lt; A[i].w &lt;&lt; endl;
                if(!_union(u,v)){
                    ans += j;
                    res++;
                }if(res==n*m-1)break;
            }
            if(res==n*m-1)break;
        }
         
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h3 id="code普通做法1719ms">code(普通做法1719ms)</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e3+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int x[man*man],fa[man*man],va[man][man];
int sz[man*man];
struct node{
    int u,v,w;
    bool operator &lt;(const node &amp;t)const{
        return w &gt; t.w;
    }
}A[2*man*man];
// int find(int x){
//     return x == fa[x] ? x : fa[x] = find(fa[x]);
// }
 
int find(int x){
    int p = x, t;
    while(p != fa[p]) p = fa[p];
    while(x != p){
        t = fa[x];
        fa[x] = p;
        x = t;
    }
    return x;
}
 
bool _union(int u,int v){
   // cout &lt;&lt; u &lt;&lt; &quot; 1\&quot; &quot; &lt;&lt; v &lt;&lt;endl;
    u = find(u);
    v = find(v);
  //  cout &lt;&lt; u &lt;&lt; &quot; 2\&quot; &quot; &lt;&lt; v &lt;&lt; endl;
    if(u==v)return true;
    if(sz[u]&gt;sz[v]){
        sz[u] += sz[v];
        fa[v] = u;
    }else fa[u] = v,sz[v] += sz[u];
    return false;
}
 
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int T = 0;
    while(t--){
        int n,m,s,a,b,c,p;
        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;s,&amp;s,&amp;s);
        scanf(&quot;%d%d%d%d%d%d&quot;,x+1,x+2,&amp;a,&amp;b,&amp;c,&amp;p);
        fa[1] = 1;
        fa[2] = 2;
        for(int i = 3;i &lt;= n*m;i++){
            fa[i] = i;
            sz[i] = 1;
            x[i] = (a*x[i-1] + b*x[i-2] + c)%p;
        }
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            for(int j = 1;j &lt;= m;j++){
                va[i][j] = x[(i-1)*m + j];
                if(!va[i][j])continue;
                if(i&gt;1&amp;&amp;va[i-1][j])A[cnt++] = node{(i-1)*m + j,(i-2)*m + j,va[i][j]*va[i-1][j]};
                if(j&gt;1&amp;&amp;va[i][j-1])A[cnt++] = node{(i-1)*m + j,(i-1)*m + j - 1,va[i][j]*va[i][j-1]};
            }
        }
        //cout &lt;&lt; &quot;cnt:&quot; &lt;&lt; cnt &lt;&lt;endl;
        sort(A,A+cnt);
        ll ans = 0;
        int res = 0;
        for(int i = 0;i &lt; cnt;i++){
            int u = A[i].u;
            int v = A[i].v;
            int w = A[i].w;
            //cout &lt;&lt; A[i].w &lt;&lt; endl;
            if(!_union(u,v)){
                ans += w;
                res++;
            }
            if(res==n*m-1)break;
        }
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h1 id="fa-simple-problem-on-a-tree"><a href="https://ac.nowcoder.com/acm/contest/4370/F">F	A Simple Problem On A Tree</a></h1>
<p>题意：一棵树，有权值，4种操作，<br>
1：u,v路径上的点权值全部为w<br>
2：u,v路径上的点权值全部加w<br>
3：u,v路径上的点权值全部乘w<br>
4：u,v路径上的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>和</p>
<p>思路：<br>
首先肯定是要把树上的操作转换为连续区间，所以(树)刨一下,然后接下来就是线段树操作了。<br>
线段树操作：<br>
求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>的和，所以我们维护一个sum3，表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。建树pushup(初始情况)<br>
然后对于更新操作，假设a,b,c,加上x，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>+</mo><mo>(</mo><mi>b</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>+</mo><mo>(</mo><mi>c</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>=</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><msup><mi>b</mi><mn>3</mn></msup><mo>+</mo><msup><mi>c</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mi>x</mi><mo>∗</mo><mo>(</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><msup><mi>c</mi><mn>2</mn></msup><mo>)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><msup><mi>x</mi><mn>2</mn></msup><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(a+x)^3 + (b + x)^3 + (c + x )^3 = a^3 + b^3 + c^3 +3*x*(a^2 + b^2 + c^2) + 3*x^2*(a+ b + c) + 3*x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><br>
然后我们再维护一个sum2(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">w^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>),sum1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>)，进行区间加的时候直接加上这个式子就ok。<br>
对于乘法的话，我们只需要把这个区间的sum3*<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>就是了。<br>
然后对于操作1，我们先对这个区间乘以0，在加上w。<br>
<mark>对于lazy标记</mark><br>
有2个(乘法，除法)标记，ad = 0,mu = 1.<br>
然后我们是先乘还是先加？<br>
假设我们先乘在加。<br>
(a + x)<em>y = a</em>y + x*y<br>
所以我们还是先区间乘上y，然后把这个区间的ad乘上y，用更新过的ad去进行加的操作<br>
先加在乘的话就可以依次进行。</p>
<h1 id="code1989ms">Code(1989ms)</h1>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

//#define int long long
vector&lt;int&gt;sp[man];
int va[man];
int top[man],rk[man],id[man],siz[man];
int son[man],fa[man],dep[man];
int cnt = 0;
void dfs1(int u,int f){
    siz[u] = 1;
    fa[u] = f;
    dep[u] = dep[f] + 1;
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==f)continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[son[u]]&lt;siz[v]){
            son[u] = v;
        }
    }
}

void dfs2(int u,int tp){
    id[++cnt] = u;
    rk[u] = cnt;
    top[u] = tp;
    if(!son[u])return;
    dfs2(son[u],tp);
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}

ll sum1[man&lt;&lt;2],sum2[man&lt;&lt;2],sum3[man&lt;&lt;2];
int ad[man&lt;&lt;2],mu[man&lt;&lt;2];
inline void add(ll &amp;x, int y){ 
    (x += y) &gt;= mod ?  x -= mod : x; 
}
inline void mul(ll &amp;x, int y){
    x = 1ll * x * y % mod; 
}
void pushup(int rt){
    sum1[rt] = (sum1[rt&lt;&lt;1] + sum1[rt&lt;&lt;1|1])%mod;
    sum2[rt] = (sum2[rt&lt;&lt;1] + sum2[rt&lt;&lt;1|1])%mod;
    sum3[rt] = (sum3[rt&lt;&lt;1] + sum3[rt&lt;&lt;1|1])%mod;
}

inline void pushdown1(int rt,int x,int y,int num){
    if(y!=1){//*
        int w1 = y;
        int w2 = 1ll*y*y%mod;
        int w3 = 1ll*w2*y%mod;
        mul(sum1[rt],w1);
        mul(sum2[rt],w2);
        mul(sum3[rt],w3);

        mu[rt] = 1ll*mu[rt]*y%mod;
        ad[rt] = 1ll*ad[rt]*y%mod;
    }
    if(x!=0){//+
        int w1 = x;
        int w2 = 1ll*x*x%mod;
        int w3 = 1ll*w2*x%mod;
        add(sum3[rt],3ll*w1%mod*sum2[rt]%mod);
        add(sum3[rt],3ll*w2%mod*sum1[rt]%mod);
        add(sum3[rt],1ll*num*w3%mod);

        add(sum2[rt],1ll*num*w2 % mod);
        add(sum2[rt],2LL*w1*sum1[rt] % mod);

        add(sum1[rt],1ll*num*w1%mod);

        ad[rt] = (1ll*ad[rt] + w1)%mod;
    }
}

inline void pushdown(int rt,int ls,int rs){
    int x = ad[rt];
    int y = mu[rt];
    pushdown1(rt&lt;&lt;1,x,y,ls);
    pushdown1(rt&lt;&lt;1|1,x,y,rs);
    ad[rt] = 0;
    mu[rt] = 1;
}

inline void build(int l,int r,int rt){
    sum1[rt] = sum2[rt] = sum3[rt] = 0;
    ad[rt] = 0;
    mu[rt] = 1;
    if(l==r){
        //cout &lt;&lt; &quot;l:&quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; id[l] &lt;&lt; endl;
        sum1[rt] = va[id[l]];
        sum2[rt] = 1ll * va[id[l]] * va[id[l]] % mod;
        sum3[rt] = 1ll * sum2[rt] * va[id[l]] % mod;
        return;
    }
    int m = l + r &gt;&gt; 1;
    build(l,m,rt&lt;&lt;1);
    build(m+1,r,rt&lt;&lt;1|1);
    pushup(rt);
}

inline void update(int l,int r,int L,int R,int rt,int op,int v){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        //更新
        if(op==1){
            pushdown1(rt,v,0,r - l + 1);
        }else if(2==op){
            pushdown1(rt,v,1,r - l + 1);
        }else{
            pushdown1(rt,0,v,r - l + 1);
        }
        return;
    }
    int m = l + r &gt;&gt; 1;
    pushdown(rt,m-l+1,r-m);
    if(L&lt;=m)update(l,m,L,R,rt&lt;&lt;1,op,v);
    if(R&gt;m)update(m+1,r,L,R,rt&lt;&lt;1|1,op,v);
    pushup(rt);
}

inline int query(int l,int r,int L,int R,int rt){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        //cout &lt;&lt; l &lt;&lt; &quot; l:r &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; L &lt;&lt; &quot; L:R &quot; &lt;&lt; R &lt;&lt;endl;
        return sum3[rt];
    }
    int m = l + r &gt;&gt; 1;
    pushdown(rt,m-l+1,r-m);
    int ans = 0;
    if(L&lt;=m)ans = (ans + query(l,m,L,R,rt&lt;&lt;1))%mod;
    if(R&gt;m)ans = (ans + query(m+1,r,L,R,rt&lt;&lt;1|1))%mod;
    pushup(rt);
    return ans;
}

void update(int u,int v,int op,int V){
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]]){
            swap(u,v);
        }
        update(1,cnt,rk[top[u]],rk[u],1,op,V);
        u = fa[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    update(1,cnt,rk[v],rk[u],1,op,V);
}

ll query(int u,int v){
    ll ans = 0;
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]]){
            swap(u,v);
        }
        int tp = query(1,cnt,rk[top[u]],rk[u],1);
        add(ans,tp);
        //cout &lt;&lt;&quot;u:&quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; u  &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; &quot;tp:&quot; &lt;&lt; tp &lt;&lt; endl;
        u = fa[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    add(ans,query(1,cnt,rk[v],rk[u],1));
    //cout &lt;&lt;&quot;u:&quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt;&quot; &quot; &lt;&lt; ans &lt;&lt; endl;
    return ans;
}

signed main() {
    #ifndef ONLINE_JUDGE
        freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t,T = 0;
    scanf(&quot;%d&quot;,&amp;t);
    //cout &lt;&lt; t &lt;&lt; endl;
    while(t--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i = 1;i &lt;= n;i++)sp[i].clear(),son[i] = 0;
        for(int i = 1;i &lt; n;i++){
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            sp[u].push_back(v);
            sp[v].push_back(u);
        }
        for(int i = 1;i &lt;= n;i++)scanf(&quot;%d&quot;,&amp;va[i]);
        dep[0] = 0;cnt = 0;
        dfs1(1,0);
        dfs2(1,1);
        build(1,cnt,1);
        //cout &lt;&lt; &quot;!!!!&quot; &lt;&lt; endl;
        printf(&quot;Case #%d: \n&quot;,++T);
        int q;scanf(&quot;%d&quot;,&amp;q);
        while(q--){
            int op,u,v,w;
            scanf(&quot;%d&quot;,&amp;op);
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            if(4!=op){
                scanf(&quot;%d&quot;,&amp;w);
                update(u,v,op,w);
            }else{
                printf(&quot;%d\n&quot;,query(u,v));
            }
        }
    }   
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://nofuck.github.io/post/hello-gridea/</id>
        <link href="https://nofuck.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>