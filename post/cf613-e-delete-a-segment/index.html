<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>cf613 E Delete a Segment | nofuck</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://nofuck.github.io/favicon.ico?v=1582449782804">
<link rel="stylesheet" href="https://nofuck.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="题意
有(n&lt;=1e5)(n&lt;=1e5)(n&lt;=1e5)个区间，要求删掉一个区间，使剩下的区间不覆盖的个数。
思路
2中做法
线段树
首先给出的区间是乱序的，对其排个序，然后我们可以一次枚举删掉这个区间，然后求剩下的区间所..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://nofuck.github.io">
        <img src="https://nofuck.github.io/images/avatar.png?v=1582449782804" class="site-logo">
        <h1 class="site-title">nofuck</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/nofuck" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      只有颓废是不需要努力得来的
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/nofuck" target="_blank">nofuck</a> | <a class="rss" href="https://nofuck.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">cf613 E Delete a Segment</h2>
            <div class="post-date">2020-02-20</div>
            
            <div class="post-content" v-pre>
              <h1 id="题意">题意</h1>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n&lt;=1e5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>个区间，要求删掉一个区间，使剩下的区间不覆盖的个数。</p>
<h1 id="思路">思路</h1>
<h2 id="2中做法">2中做法</h2>
<h4 id="线段树">线段树</h4>
<p>首先给出的区间是乱序的，对其排个序，然后我们可以一次枚举删掉这个区间，然后求剩下的区间所剩的个数。可以用线段树来进行更新查询，可以类似求区间连续01个数那种方式，但我们由于这里是区间，所以把点化为区间，把区间扩大2倍<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo>∗</mo><mi>l</mi><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[2*l,2*r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，然后多加入这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo>∗</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2*l+1,2*r+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>来进行离散化，最后就是区间线段树的操作，只不过pushup的时候我们有细节，如果这个区间全部被覆盖，那么就不用从下面得到答案，直接更新为1就ok了</p>
<h4 id="code">code</h4>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 4e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int a[man*2];

struct node{
    int cnt;
    bool lc,rc;//这段区间的左右区间是否被覆盖
    node(){
        cnt = 0;
        lc = rc = 0;
    }
}tr[man*30];
int flag[man*30];

void build(int l,int r,int rt){
    flag[rt] = 0;
    tr[rt].cnt = 0;
    tr[rt].lc = tr[rt].rc = 0;
    if(l==r){
        //把叶子的下面给清掉
        tr[rt&lt;&lt;1].cnt = tr[rt&lt;&lt;1|1].cnt = 0;
        tr[rt&lt;&lt;1].lc = tr[rt&lt;&lt;1].rc = 0;
        tr[rt&lt;&lt;1|1].lc = tr[rt&lt;&lt;1|1].rc = 0;
        return;
    }
    int m = l + r &gt;&gt; 1;
    build(l,m,rt&lt;&lt;1);
    build(m+1,r,rt&lt;&lt;1|1);
}

void pushup(int rt){
    if(flag[rt]){//如果这整个区间都覆盖，则就为1了，
        tr[rt].cnt = 1;
        tr[rt].lc = tr[rt].rc = 1;
    }else{
        tr[rt].cnt = tr[rt&lt;&lt;1].cnt  + tr[rt&lt;&lt;1|1].cnt;
        if(tr[rt&lt;&lt;1].rc&amp;&amp;tr[rt&lt;&lt;1|1].lc)tr[rt].cnt--;
        tr[rt].lc = tr[rt&lt;&lt;1].lc;
        tr[rt].rc = tr[rt&lt;&lt;1|1].rc;
    }
}

void update(int l,int r,int L,int R,int rt,int v){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        flag[rt]+= v;//打标机并更新。
        pushup(rt);
        return;
    }
    int m = l + r &gt;&gt;1;  
    if(L&lt;=m)update(l,m,L,R,rt&lt;&lt;1,v);
    if(R&gt;m)update(m+1,r,L,R,rt&lt;&lt;1|1,v);
    pushup(rt);
}

pair&lt;int,int&gt;b[man];
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            int l,r;
            cin &gt;&gt; l &gt;&gt; r;
            l = l*2;r = 2*r;
            b[i].first = l;
            b[i].second = r;
            a[cnt++] = l;
            a[cnt++] = l+1;
            a[cnt++] = r;
            a[cnt++] = r+1;
        }
        sort(a,a+cnt);
        cnt = unique(a,a+cnt) - a;
        build(1,cnt,1);
        int ans = -1;
        for(int i = 1;i &lt;= n;i++){
            int l = lower_bound(a,a+cnt,b[i].first) - a + 1;
            int r = lower_bound(a,a+cnt,b[i].second) - a + 1;
            update(1,cnt,l,r,1,1);
        }
        for(int i = 1;i &lt;= n;i++){
            int l = lower_bound(a,a+cnt,b[i].first) - a + 1;
            int r = lower_bound(a,a+cnt,b[i].second) - a + 1;
            update(1,cnt,l,r,1,-1);
            ans = max(ans,tr[1].cnt);
            update(1,cnt,l,r,1,1);
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }   
    return 0;
}
</code></pre>
<h3 id="单调栈">单调栈</h3>
<p>首先考虑我们删掉中间的一个 线段，左边的个数我们可以通过前缀num得到，num[i]就是前i个区间有多少个不相邻的区间，然后可以用max_r来得到,如果当前的L大于max_r[i-1]，那么num就会增加一个，依次累加就ok，那么右边的区间又如何得到，因为我们的l从后往前，依次递减，然后我们只需要最小的L，与最小的L的区间相互重叠的区间我们是用不到的，因为可以看成一个区间，所以只有这个最小的L有用，然后右边的一部分我们可以用单调栈维护L（后往前）。<br>
整个过程就是从后往前得到答案，然后维护单调栈里的元素，每次的答案就是num[i-1] + cnt<br>
cnt就是单调栈里大于max_r[i-1]的个数，可以二分得到</p>
<h4 id="code-2">code</h4>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
pair&lt;int,int&gt;sp[man];
int num[man],sta[man],max_r[man];
int top;

int bin(int x){
    int l = 1,r = top;
    int ans = 0;
    while(l&lt;=r){
        int mid = l + r &gt;&gt; 1;
        if(sta[mid]&gt;=x){
            l = mid + 1;
            ans = mid;
        }else r = mid - 1;
    }
    if(sta[ans]==x)ans--;
    return ans;
}


int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        max_r[0] = -INT_MAX;
        num[0] = 0;top= 0;
        for(int i = 1;i &lt;= n;++i){
            scanf(&quot;%d%d&quot;,&amp;sp[i].first,&amp;sp[i].second);
        }
        sort(sp+1,sp+1+n);
        for(int i = 1;i &lt;= n;++i){
            max_r[i] = max(sp[i].second,max_r[i-1]);
            if(sp[i].first&gt;max_r[i-1])num[i] = 1;
            num[i] += num[i-1];
        }
        int ans = 0;
        for(int i = n;i &gt;= 1;i--){
            ans = max(ans,num[i-1]+bin(max_r[i-1]));
            while(top&amp;&amp;sp[i].second&gt;=sta[top])top--;
            sta[++top] = sp[i].first;
            num[i] = 0;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://nofuck.github.io/post/2019icpc-shang-hai-qu-yu-sai-bkdefh/">
                  <h3 class="post-title">
                    2019icpc上海区域赛B,K,D,E,F,H
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
