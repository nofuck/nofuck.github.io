<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2019icpc上海区域赛B,K,D,E,F,H | nofuck</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://nofuck.github.io/favicon.ico?v=1582347503862">
<link rel="stylesheet" href="https://nofuck.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="😊😊
B	Prefix Code
题意：给出n个数字(有前缀0)，长度均小于10，问是否有一个数是其他数的前缀？
思路：字典树查找即可，vis表示走过的路径和ed标记结尾，在insert就可判断。
code
#pragma GCC op..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://nofuck.github.io">
        <img src="https://nofuck.github.io/images/avatar.png?v=1582347503862" class="site-logo">
        <h1 class="site-title">nofuck</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/nofuck" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      只有颓废是不需要努力得来的
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/nofuck" target="_blank">nofuck</a> | <a class="rss" href="https://nofuck.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">2019icpc上海区域赛B,K,D,E,F,H</h2>
            <div class="post-date">2020-02-20</div>
            
            <div class="post-content" v-pre>
              <p>😊😊</p>
<h1 id="bprefix-code"><a href="https://ac.nowcoder.com/acm/contest/4370/B">B	Prefix Code</a></h1>
<p>题意：给出n个数字(有前缀0)，长度均小于10，问是否有一个数是其他数的前缀？<br>
思路：字典树查找即可，vis表示走过的路径和ed标记结尾，在insert就可判断。</p>
<h3 id="code">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e4+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

int tr[man*15][10];
int cnt = 0;
int vis[man*15];
bool ed[man*15];
bool ans;
void insert(const char *s){
    int p = 0;
    for(int i = 0;s[i];i++){
        int tp = s[i] - '0';
        if(!tr[p][tp])tr[p][tp] = ++cnt;
        p = tr[p][tp];
        if(ed[p])ans = 1;//这个数包含其它前缀
        vis[p]++;
    }
    if(vis[p]&gt;1)ans = 1;//这个数为其它数的前缀
    ed[p] = 1;
}

void init(){
    for(int i = 0;i &lt;= cnt;i++){
        memset(tr[i],0,sizeof(tr[i]));
        vis[i] = 0;
        ed[i] = 0;
    }
    cnt = 0;
    ans = 0;
}

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt;t;
    int T = 1;
    while(t--){
        int n;
        init();
        cin &gt;&gt; n;
        char str[15];
        while(n--){
            cin &gt;&gt; str;
            insert(str);
        }
        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; T++ &lt;&lt;&quot;:&quot;;
        if(ans)cout &lt;&lt; &quot; No\n&quot;;
        else cout &lt;&lt; &quot; Yes\n&quot;;  
    }   
    return 0;
}
</code></pre>
<h1 id="kcolor-graph"><a href="https://ac.nowcoder.com/acm/contest/4370/K">K	Color Graph</a></h1>
<p>题意：给定一个简单图，点个数&lt;=16，对一些边涂色，使得该图中涂过色没有奇数的环，问涂色的边数最大为多少。<br>
思路：<strong>如果一个图中不存在奇数环,那么这个图一定是二分图(首先如果没有环(树)，那么一定是二分图，如果有偶数环，那么从左边的点出去到右边肯定是奇数次，如果要回到左边肯定得是偶数，所以粗略可得。)<a href="https://www.cnblogs.com/ninedream/p/11203942.html">证明</a></strong>，然后点数很小，所以二进制枚举二分图左边的点数，取个最大值。</p>
<h3 id="code-2">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e4+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

vector&lt;pair&lt;int,int&gt; &gt;sp;
bool vis[20];

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    IOS;
    int t;
    cin &gt;&gt;t;
    int T = 1;
    while(t--){
        int n,m;
        cin &gt;&gt; n &gt;&gt; m;
        sp.clear();
        memset(vis,0,sizeof(vis));
        for(int i = 1;i &lt;= m;++i){
            int u,v;
            cin &gt;&gt; u &gt;&gt; v;
            sp.push_back(make_pair(u,v));
        }
        int ans = 0;
        for(int i = 0;i &lt; (1&lt;&lt;n);++i){
            int tp = i;
            for(int j = 1;j &lt;= n;j++){
                if(tp&gt;&gt;(j-1)&amp;1)vis[j] = 1;
                else vis[j] = 0;
            }
            int res = 0;
            for(int j = 0;j &lt; sp.size();++j){
                if(vis[sp[j].first]!=vis[sp[j].second])res++;
            }
            ans = max(ans,res);
        }
        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; T++ &lt;&lt;&quot;: &quot;;
        cout &lt;&lt; ans &lt;&lt; endl;
    }   
    return 0;
}
</code></pre>
<h1 id="htree-partition"><a href="https://ac.nowcoder.com/acm/contest/4370/H">H	Tree Partition</a></h1>
<p>题意：一颗(n&lt;=1e5)的树，要求把其分为(k&lt;=n)个子树，要求每个子树的最大值最小。<br>
思路：首先二分最大值mid，然后在对于这个最大值check，让每颗树都尽量的大(&lt;=x)，以致于我们砍的次数少，如果砍的次数多了，那么说明这个max小了，反之则大了。</p>
<h3 id="code-3">code</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
vector&lt;int&gt;sp[man];
int tp[man];
ll va[man];
const ll inf = 1e18;
ll mid;
int kk;

struct node{
    int u;
    node(int u = 0):u(u){}
    bool operator &lt; (const node &amp;t)const{
        return va[u] &lt; va[t.u];
    }
};


ll dfs(int u,int f){
    priority_queue&lt;node&gt;q;
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==f)continue;
        va[u] += dfs(v,u);
        q.push(node(v));
    }
    while(va[u]&gt;mid&amp;&amp;!q.empty()){
        va[u] -= va[q.top().u];
        q.pop();
        kk++;
    }
    while(!q.empty())q.pop();
    return va[u];
}

int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    int T = 0;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        int k,n;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        //while(!q.empty())q.pop();
        for(int i = 1;i &lt;= n;i++)sp[i].clear();
        for(int i = 1;i &lt; n;i++){
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            sp[u].push_back(v);
            sp[v].push_back(u);
        }
        ll l = 0,r = inf;
        for(int i = 1;i &lt;= n;i++)scanf(&quot;%d&quot;,&amp;tp[i]),l = max(l,1ll*tp[i]);
        ll ans = 0;
        while(l&lt;=r){
            mid = l + r &gt;&gt; 1;
            for(int i = 1;i &lt;= n;i++)va[i] = tp[i];
            kk = 0;
            dfs(1,0);
            if(kk+1&lt;=k)r = mid - 1,ans = mid;
            else l = mid + 1; 
        }
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h1 id="dspanning-tree-removal"><a href="https://ac.nowcoder.com/acm/contest/4370/D">D	Spanning Tree Removal</a></h1>
<p>题意：给定一个n的完全图，每次操作是从图中移除一棵生成树的所有边，问最多能进行多少次这样的操作？输出操作次数和每次移除的生成树的边。<br>
思路：边n*(n-1)/2,每颗生成树为n-1条边，所以猜测n/2条边，构造方法的话也比较巧;<br>
所有点顺时针编号(0~n-1)<br>
以x为起点，连接的点y为顺时针+1<br>
从y找下一个点，连接的点z为逆时针-2<br>
然后形成一个z字。</p>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

int main() {
    #ifndef ONLINE_JUDGE
        freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    cin &gt;&gt; t;
    int T = 0;
    while(t--){
        int n;cin &gt;&gt; n;
        printf(&quot;Case #%d: %d\n&quot;,++T,n/2);
        for(int i = 1;i &lt;= n/2;i++){
            int f = 1;
            int u = i - 1;
            for(int j = 1;j &lt; n;j++){
                int v = (u + j*f + n)%n;
                printf(&quot;%d %d\n&quot;,u+1,v+1);
                f *= -1;
                u = v;
            }
        }
    }
    return 0;
}
</code></pre>
<h1 id="ecave-escape"><a href="https://ac.nowcoder.com/acm/contest/4370/E">E	Cave Escape</a></h1>
<p>题意：给定一个n∗m的格子矩阵，其中有一个格子是起点，一个格子是终点。从起点开始移动，每次能移动到有相邻边的格子中，每个格子都有一个权值v,若从点a移动到点b，且b点未被访问过，则可以获得Va∗Vb的收益，若移动到终点，可以选择先不出去，继续在图上乱走，问如何可以使得走出终点后获得得收益最大？(只需要输出最大收益即可)<br>
思路：不管起点在哪里，因为权值都为正数，我们要让收益最大，肯定尽量每个点都访问一遍，然后才是最大的值，所以我们可以直接建图，然后跑一遍生成树(最大),因为要让每个点访问一次。<br>
正解的话存图是把权值作为索引，然后从大到小一次枚举；<br>
一般的做法可以卡过去。</p>
<h3 id="code正解805ms">code(正解805ms)</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e3+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int x[man*man],fa[man*man],va[man][man];
int sz[man*man];
vector&lt;pair&lt;int,int&gt; &gt;A[10010];
int find(int x){
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}
/*
int find(int x){
    int p = x;
    while(p!=fa[p])p = fa[p];
    while(x!=p){
        int tp = fa[x];
        fa[x] = p;
        x = tp;
    }
    return p;
}*/
 
bool _union(int u,int v){
   // cout &lt;&lt; u &lt;&lt; &quot; 1\&quot; &quot; &lt;&lt; v &lt;&lt;endl;
    u = find(u);
    v = find(v);
  //  cout &lt;&lt; u &lt;&lt; &quot; 2\&quot; &quot; &lt;&lt; v &lt;&lt; endl;
    if(u==v)return true;
    if(sz[u]&gt;sz[v]){
        sz[u] += sz[v];
        fa[v] = u;
    }else fa[u] = v,sz[v] += sz[u];
    return false;
}
 
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int T = 0;
    while(t--){
        int n,m,s,a,b,c,p;
        for(int i = 0;i &lt;= 10000;i++)A[i].clear();
        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;s,&amp;s,&amp;s);
        scanf(&quot;%d%d%d%d%d%d&quot;,x+1,x+2,&amp;a,&amp;b,&amp;c,&amp;p);
        fa[1] = 1;
        fa[2] = 2;
        for(int i = 3;i &lt;= n*m;i++){
            fa[i] = i;
            sz[i] = 1;
            x[i] = (a*x[i-1] + b*x[i-2] + c)%p;
        }
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            for(int j = 1;j &lt;= m;j++){
                va[i][j] = x[(i-1)*m + j];
                if(!va[i][j])continue;
                if(i&gt;1&amp;&amp;va[i-1][j])A[va[i][j]*va[i-1][j]].push_back(make_pair((i-1)*m + j,(i-2)*m + j));
                if(j&gt;1&amp;&amp;va[i][j-1])A[va[i][j]*va[i][j-1]].push_back(make_pair((i-1)*m + j,(i-1)*m + j - 1));
            }
        }
        ll ans = 0;
        int res = 0;
        for(int j = 10000;j &gt;= 0;j--){
            for(int i = 0;i &lt; A[j].size();i++){
                int u = A[j][i].first;
                int v = A[j][i].second;
                //cout &lt;&lt; A[i].w &lt;&lt; endl;
                if(!_union(u,v)){
                    ans += j;
                    res++;
                }if(res==n*m-1)break;
            }
            if(res==n*m-1)break;
        }
         
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h3 id="code普通做法1719ms">code(普通做法1719ms)</h3>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 1e3+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;
int x[man*man],fa[man*man],va[man][man];
int sz[man*man];
struct node{
    int u,v,w;
    bool operator &lt;(const node &amp;t)const{
        return w &gt; t.w;
    }
}A[2*man*man];
// int find(int x){
//     return x == fa[x] ? x : fa[x] = find(fa[x]);
// }
 
int find(int x){
    int p = x, t;
    while(p != fa[p]) p = fa[p];
    while(x != p){
        t = fa[x];
        fa[x] = p;
        x = t;
    }
    return x;
}
 
bool _union(int u,int v){
   // cout &lt;&lt; u &lt;&lt; &quot; 1\&quot; &quot; &lt;&lt; v &lt;&lt;endl;
    u = find(u);
    v = find(v);
  //  cout &lt;&lt; u &lt;&lt; &quot; 2\&quot; &quot; &lt;&lt; v &lt;&lt; endl;
    if(u==v)return true;
    if(sz[u]&gt;sz[v]){
        sz[u] += sz[v];
        fa[v] = u;
    }else fa[u] = v,sz[v] += sz[u];
    return false;
}
 
int main() {
    #ifndef ONLINE_JUDGE
        //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int T = 0;
    while(t--){
        int n,m,s,a,b,c,p;
        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;s,&amp;s,&amp;s);
        scanf(&quot;%d%d%d%d%d%d&quot;,x+1,x+2,&amp;a,&amp;b,&amp;c,&amp;p);
        fa[1] = 1;
        fa[2] = 2;
        for(int i = 3;i &lt;= n*m;i++){
            fa[i] = i;
            sz[i] = 1;
            x[i] = (a*x[i-1] + b*x[i-2] + c)%p;
        }
        int cnt = 0;
        for(int i = 1;i &lt;= n;i++){
            for(int j = 1;j &lt;= m;j++){
                va[i][j] = x[(i-1)*m + j];
                if(!va[i][j])continue;
                if(i&gt;1&amp;&amp;va[i-1][j])A[cnt++] = node{(i-1)*m + j,(i-2)*m + j,va[i][j]*va[i-1][j]};
                if(j&gt;1&amp;&amp;va[i][j-1])A[cnt++] = node{(i-1)*m + j,(i-1)*m + j - 1,va[i][j]*va[i][j-1]};
            }
        }
        //cout &lt;&lt; &quot;cnt:&quot; &lt;&lt; cnt &lt;&lt;endl;
        sort(A,A+cnt);
        ll ans = 0;
        int res = 0;
        for(int i = 0;i &lt; cnt;i++){
            int u = A[i].u;
            int v = A[i].v;
            int w = A[i].w;
            //cout &lt;&lt; A[i].w &lt;&lt; endl;
            if(!_union(u,v)){
                ans += w;
                res++;
            }
            if(res==n*m-1)break;
        }
        printf(&quot;Case #%d: %lld\n&quot;,++T,ans);
    }
    return 0;
}
</code></pre>
<h1 id="fa-simple-problem-on-a-tree"><a href="https://ac.nowcoder.com/acm/contest/4370/F">F	A Simple Problem On A Tree</a></h1>
<p>题意：一棵树，有权值，4种操作，<br>
1：u,v路径上的点权值全部为w<br>
2：u,v路径上的点权值全部加w<br>
3：u,v路径上的点权值全部乘w<br>
4：u,v路径上的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>和</p>
<p>思路：<br>
首先肯定是要把树上的操作转换为连续区间，所以(树)刨一下,然后接下来就是线段树操作了。<br>
线段树操作：<br>
求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>的和，所以我们维护一个sum3，表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">w^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。建树pushup(初始情况)<br>
然后对于更新操作，假设a,b,c,加上x，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>+</mo><mo>(</mo><mi>b</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>+</mo><mo>(</mo><mi>c</mi><mo>+</mo><mi>x</mi><msup><mo>)</mo><mn>3</mn></msup><mo>=</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><msup><mi>b</mi><mn>3</mn></msup><mo>+</mo><msup><mi>c</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mi>x</mi><mo>∗</mo><mo>(</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><msup><mi>c</mi><mn>2</mn></msup><mo>)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><msup><mi>x</mi><mn>2</mn></msup><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(a+x)^3 + (b + x)^3 + (c + x )^3 = a^3 + b^3 + c^3 +3*x*(a^2 + b^2 + c^2) + 3*x^2*(a+ b + c) + 3*x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><br>
然后我们再维护一个sum2(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>w</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">w^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>),sum1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>)，进行区间加的时候直接加上这个式子就ok。<br>
对于乘法的话，我们只需要把这个区间的sum3*<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">x^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>就是了。<br>
然后对于操作1，我们先对这个区间乘以0，在加上w。<br>
<mark>对于lazy标记</mark><br>
有2个(乘法，除法)标记，ad = 0,mu = 1.<br>
然后我们是先乘还是先加？<br>
假设我们先乘在加。<br>
(a + x)<em>y = a</em>y + x*y<br>
所以我们还是先区间乘上y，然后把这个区间的ad乘上y，用更新过的ad去进行加的操作<br>
先加在乘的话就可以依次进行。</p>
<h1 id="code1989ms">Code(1989ms)</h1>
<pre><code class="language-cpp">#pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int man = 2e5+10;
#define IOS ios::sync_with_stdio(0)
template &lt;typename T&gt;
inline T read(){T sum=0,fl=1;int ch=getchar();
for(;!isdigit(ch);ch=getchar())if(ch=='-')fl=-1;
for(;isdigit(ch);ch=getchar())sum=sum*10+ch-'0';
return sum*fl;}
template &lt;typename T&gt;
inline void write(T x) {static int sta[35];int top=0;
do{sta[top++]= x % 10, x /= 10;}while(x);
while (top) putchar(sta[--top] + 48);}
template&lt;typename T&gt;T gcd(T a, T b) {return b==0?a:gcd(b, a%b);}
template&lt;typename T&gt;T exgcd(T a,T b,T &amp;g,T &amp;x,T &amp;y){if(!b){g = a,x = 1,y = 0;}
else {exgcd(b,a%b,g,y,x);y -= x*(a/b);}}
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) {printf(&quot;debug &quot;);printf(fmt,##__VA_ARGS__);puts(&quot;&quot;);}
#else
#define debug(fmt, ...)
#endif
typedef long long ll;
const ll mod = 1e9+7;

//#define int long long
vector&lt;int&gt;sp[man];
int va[man];
int top[man],rk[man],id[man],siz[man];
int son[man],fa[man],dep[man];
int cnt = 0;
void dfs1(int u,int f){
    siz[u] = 1;
    fa[u] = f;
    dep[u] = dep[f] + 1;
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==f)continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[son[u]]&lt;siz[v]){
            son[u] = v;
        }
    }
}

void dfs2(int u,int tp){
    id[++cnt] = u;
    rk[u] = cnt;
    top[u] = tp;
    if(!son[u])return;
    dfs2(son[u],tp);
    for(int i = 0;i &lt; sp[u].size();i++){
        int v = sp[u][i];
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}

ll sum1[man&lt;&lt;2],sum2[man&lt;&lt;2],sum3[man&lt;&lt;2];
int ad[man&lt;&lt;2],mu[man&lt;&lt;2];
inline void add(ll &amp;x, int y){ 
    (x += y) &gt;= mod ?  x -= mod : x; 
}
inline void mul(ll &amp;x, int y){
    x = 1ll * x * y % mod; 
}
void pushup(int rt){
    sum1[rt] = (sum1[rt&lt;&lt;1] + sum1[rt&lt;&lt;1|1])%mod;
    sum2[rt] = (sum2[rt&lt;&lt;1] + sum2[rt&lt;&lt;1|1])%mod;
    sum3[rt] = (sum3[rt&lt;&lt;1] + sum3[rt&lt;&lt;1|1])%mod;
}

inline void pushdown1(int rt,int x,int y,int num){
    if(y!=1){//*
        int w1 = y;
        int w2 = 1ll*y*y%mod;
        int w3 = 1ll*w2*y%mod;
        mul(sum1[rt],w1);
        mul(sum2[rt],w2);
        mul(sum3[rt],w3);

        mu[rt] = 1ll*mu[rt]*y%mod;
        ad[rt] = 1ll*ad[rt]*y%mod;
    }
    if(x!=0){//+
        int w1 = x;
        int w2 = 1ll*x*x%mod;
        int w3 = 1ll*w2*x%mod;
        add(sum3[rt],3ll*w1%mod*sum2[rt]%mod);
        add(sum3[rt],3ll*w2%mod*sum1[rt]%mod);
        add(sum3[rt],1ll*num*w3%mod);

        add(sum2[rt],1ll*num*w2 % mod);
        add(sum2[rt],2LL*w1*sum1[rt] % mod);

        add(sum1[rt],1ll*num*w1%mod);

        ad[rt] = (1ll*ad[rt] + w1)%mod;
    }
}

inline void pushdown(int rt,int ls,int rs){
    int x = ad[rt];
    int y = mu[rt];
    pushdown1(rt&lt;&lt;1,x,y,ls);
    pushdown1(rt&lt;&lt;1|1,x,y,rs);
    ad[rt] = 0;
    mu[rt] = 1;
}

inline void build(int l,int r,int rt){
    sum1[rt] = sum2[rt] = sum3[rt] = 0;
    ad[rt] = 0;
    mu[rt] = 1;
    if(l==r){
        //cout &lt;&lt; &quot;l:&quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; id[l] &lt;&lt; endl;
        sum1[rt] = va[id[l]];
        sum2[rt] = 1ll * va[id[l]] * va[id[l]] % mod;
        sum3[rt] = 1ll * sum2[rt] * va[id[l]] % mod;
        return;
    }
    int m = l + r &gt;&gt; 1;
    build(l,m,rt&lt;&lt;1);
    build(m+1,r,rt&lt;&lt;1|1);
    pushup(rt);
}

inline void update(int l,int r,int L,int R,int rt,int op,int v){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        //更新
        if(op==1){
            pushdown1(rt,v,0,r - l + 1);
        }else if(2==op){
            pushdown1(rt,v,1,r - l + 1);
        }else{
            pushdown1(rt,0,v,r - l + 1);
        }
        return;
    }
    int m = l + r &gt;&gt; 1;
    pushdown(rt,m-l+1,r-m);
    if(L&lt;=m)update(l,m,L,R,rt&lt;&lt;1,op,v);
    if(R&gt;m)update(m+1,r,L,R,rt&lt;&lt;1|1,op,v);
    pushup(rt);
}

inline int query(int l,int r,int L,int R,int rt){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        //cout &lt;&lt; l &lt;&lt; &quot; l:r &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; L &lt;&lt; &quot; L:R &quot; &lt;&lt; R &lt;&lt;endl;
        return sum3[rt];
    }
    int m = l + r &gt;&gt; 1;
    pushdown(rt,m-l+1,r-m);
    int ans = 0;
    if(L&lt;=m)ans = (ans + query(l,m,L,R,rt&lt;&lt;1))%mod;
    if(R&gt;m)ans = (ans + query(m+1,r,L,R,rt&lt;&lt;1|1))%mod;
    pushup(rt);
    return ans;
}

void update(int u,int v,int op,int V){
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]]){
            swap(u,v);
        }
        update(1,cnt,rk[top[u]],rk[u],1,op,V);
        u = fa[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    update(1,cnt,rk[v],rk[u],1,op,V);
}

ll query(int u,int v){
    ll ans = 0;
    while(top[u]!=top[v]){
        if(dep[top[u]]&lt;dep[top[v]]){
            swap(u,v);
        }
        int tp = query(1,cnt,rk[top[u]],rk[u],1);
        add(ans,tp);
        //cout &lt;&lt;&quot;u:&quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; u  &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; &quot;tp:&quot; &lt;&lt; tp &lt;&lt; endl;
        u = fa[top[u]];
    }
    if(dep[u]&lt;dep[v])swap(u,v);
    add(ans,query(1,cnt,rk[v],rk[u],1));
    //cout &lt;&lt;&quot;u:&quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; top[u] &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt;&quot; &quot; &lt;&lt; ans &lt;&lt; endl;
    return ans;
}

signed main() {
    #ifndef ONLINE_JUDGE
        freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
        //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    int t,T = 0;
    scanf(&quot;%d&quot;,&amp;t);
    //cout &lt;&lt; t &lt;&lt; endl;
    while(t--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i = 1;i &lt;= n;i++)sp[i].clear(),son[i] = 0;
        for(int i = 1;i &lt; n;i++){
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            sp[u].push_back(v);
            sp[v].push_back(u);
        }
        for(int i = 1;i &lt;= n;i++)scanf(&quot;%d&quot;,&amp;va[i]);
        dep[0] = 0;cnt = 0;
        dfs1(1,0);
        dfs2(1,1);
        build(1,cnt,1);
        //cout &lt;&lt; &quot;!!!!&quot; &lt;&lt; endl;
        printf(&quot;Case #%d: \n&quot;,++T);
        int q;scanf(&quot;%d&quot;,&amp;q);
        while(q--){
            int op,u,v,w;
            scanf(&quot;%d&quot;,&amp;op);
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            if(4!=op){
                scanf(&quot;%d&quot;,&amp;w);
                update(u,v,op,w);
            }else{
                printf(&quot;%d\n&quot;,query(u,v));
            }
        }
    }   
    return 0;
}
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://nofuck.github.io/post/hello-gridea/">
                  <h3 class="post-title">
                    Hello Gridea
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
